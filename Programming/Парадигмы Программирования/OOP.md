---
создал заметку: 2024-07-20T23:52:00
author: WhiteK0T
tags:
  - OOP
  - Императивное_программирование
Источник:
  - https://github.com/enhorse/java-interview/blob/master/oop.md#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%9E%D0%9E%D0%9F
  - https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/
  - https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5
---
Суть понятия **объектно-ориентированного программирования** в том, что все программы, написанные с применением этой парадигмы, состоят из объектов. Каждый объект — это определённая сущность со своими данными и набором доступных действий. Каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

#### Принципы ООП.
- _Инкапсуляция_ - сокрытие реализации.
- _Наследование_ - создание новой сущности на базе уже существующей.
- _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
- _Абстракция_ - набор общих характеристик.
##### Инкапсуляция
**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.
Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса от реализации. **Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.**
Пример любой пульт.
##### Наследование
**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Класс, от которого производится наследование, называется _предком_, _базовым_, _родительским_ или _суперклассом_. Новый класс – _потомком_, _наследником_, _дочерним_ или _производным_ классом.
##### Полиморфизм
**Полиморфизм** – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).
##### Абстракция
_Абстрагирование_ означает выделение значимой информации и исключение из рассмотрения не значимой. В ООП рассматривают лишь абстракцию данных (нередко называя её просто «абстракцией»), подразумевая набор наиболее значимых характеристик объекта, доступных остальной программе.

#### В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?

##### Преимущества 
- **В парадигме объектов легче писать код.** Удобно один раз создать класс или метод, а потом его использовать. Не нужно повторно переписывать десятки строк кода. 
- **Читать код гораздо проще.** Даже в чужом коде обычно сразу видны конкретные объекты и методы, их удобно искать, чтобы посмотреть, что именно они делают. 
- **Код легче обновлять.** Класс или метод достаточно изменить в одном месте, чтобы он изменился во всех наследуемых классах и объектах. Не нужно переписывать каждый объект отдельно, выискивая, где именно в коде он расположен. 
- **Программистам удобнее работать в команде.** Разные люди могут отвечать за разные объекты и при этом пользоваться плодами трудов коллег. 
- **Код можно переиспользовать.** Один раз написанный класс или объект можно затем переносить в другие проекты. Достаточно однажды написать объект «Кнопка заказа» и потом можно вставлять его в почти неизменном виде в разные каталоги товаров и мобильные приложения. 
- **Шаблоны проектирования.** Именно на базе ООП построены готовые решения для взаимодействия классов друг с другом, которые позволяют не писать этот код с нуля, а взять шаблон.
##### Недостатки
- **Сложность в освоении.** ООП сложнее, чем функциональное программирование. Для написания кода в этой парадигме нужно знать гораздо больше. Поэтому перед созданием первой рабочей программы придётся освоить много информации: разобраться в классах и наследовании, научиться писать публичные и внутренние функции, изучить способы взаимодействия объектов между собой.
- **Громоздкость.** Там, где в функциональном программировании хватит одной функции, в ООП нужно создать класс, объект, методы и атрибуты. Для больших программ это плюс, так как структура будет понятной, а для маленьких может оказаться лишней тратой времени.
- **Низкая производительность.** Объекты потребляют больше памяти, чем простые функции и переменные. Скорость компиляции от этого тоже страдает.

#### Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?
**«является»**(is a) подразумевает наследование. **«имеет»**(has a) подразумевает ассоциацию (агрегацию или композицию).

#### Что такое ассоциация, агрегация и композиция?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».
Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть).
Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не
входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.
**Например**, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в
другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время
мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.

#### Что такое _статическое_ и _динамическое связывание_?
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется _статическим_ или _ранним связыванием (early binding)_.

В свою очередь, _позднее связывание (late binding)_ это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют _динамическим (dynamic)_ или _связыванием на стадии выполнения (runtime binding)_. В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как `final`, `static` или `private` (приватные методы являются `final` по умолчанию).

Источник [Как ООП помогает разработчикам писать код быстрее и проще](https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/), [wikipedia.org](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), [Вопросы для собеседования на Java Developer](https://github.com/enhorse/java-interview/blob/master/oop.md#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%9E%D0%9E%D0%9F), [[Императивное программирование]]

#OOP 
#Императивное_программирование 